name: Deploy AloShield

on:
  push:
    branches:
      - main
      - master
      - refactor/chat-optimization
      - refactor/chat-optimization-461835954714615953
      - optimize-performance-fullstack-15156313786622062071
      - refactor-chat-ui-architecture-13667079202460228569
  workflow_dispatch:

env:
  DOCKER_REGISTRY: docker.io
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_ACCESS_TOKEN }}

      - name: Extract metadata for backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/aloshield-backend
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract metadata for frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/aloshield-frontend
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract frontend environment variables from ENV_FE
        id: frontend-env
        run: |
          # Parse ENV_FE to extract NEXT_PUBLIC_* variables
          # Variables not found will default to empty string
          echo "${{ secrets.ENV_FE }}" > /tmp/frontend.env
          
          # Extract variables (handle cases with = in values by using sed)
          # If variable doesn't exist, grep returns nothing and we get empty string
          NEXT_PUBLIC_API_URL=$(grep "^NEXT_PUBLIC_API_URL=" /tmp/frontend.env 2>/dev/null | sed 's/^NEXT_PUBLIC_API_URL=//' | tr -d '\r' | xargs || echo "")
          NEXT_PUBLIC_WS_URL=$(grep "^NEXT_PUBLIC_WS_URL=" /tmp/frontend.env 2>/dev/null | sed 's/^NEXT_PUBLIC_WS_URL=//' | tr -d '\r' | xargs || echo "")
          NEXT_PUBLIC_SUPABASE_URL=$(grep "^NEXT_PUBLIC_SUPABASE_URL=" /tmp/frontend.env 2>/dev/null | sed 's/^NEXT_PUBLIC_SUPABASE_URL=//' | tr -d '\r' | xargs || echo "")
          NEXT_PUBLIC_SUPABASE_ANON_KEY=$(grep "^NEXT_PUBLIC_SUPABASE_ANON_KEY=" /tmp/frontend.env 2>/dev/null | sed 's/^NEXT_PUBLIC_SUPABASE_ANON_KEY=//' | tr -d '\r' | xargs || echo "")
          NEXT_PUBLIC_GOOGLE_CLIENT_ID=$(grep "^NEXT_PUBLIC_GOOGLE_CLIENT_ID=" /tmp/frontend.env 2>/dev/null | sed 's/^NEXT_PUBLIC_GOOGLE_CLIENT_ID=//' | tr -d '\r' | xargs || echo "")
          
          # Export to GITHUB_ENV for use in build-args (empty strings are OK)
          echo "NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_WS_URL=${NEXT_PUBLIC_WS_URL}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_SUPABASE_URL=${NEXT_PUBLIC_SUPABASE_URL}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_SUPABASE_ANON_KEY=${NEXT_PUBLIC_SUPABASE_ANON_KEY}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_GOOGLE_CLIENT_ID=${NEXT_PUBLIC_GOOGLE_CLIENT_ID}" >> $GITHUB_ENV
          
          # Debug output (show only non-empty variables for security)
          echo "Extracted frontend environment variables from ENV_FE:"
          [ -n "${NEXT_PUBLIC_API_URL}" ] && echo "  ✓ NEXT_PUBLIC_API_URL is set" || echo "  - NEXT_PUBLIC_API_URL is empty"
          [ -n "${NEXT_PUBLIC_WS_URL}" ] && echo "  ✓ NEXT_PUBLIC_WS_URL is set" || echo "  - NEXT_PUBLIC_WS_URL is empty"
          [ -n "${NEXT_PUBLIC_SUPABASE_URL}" ] && echo "  ✓ NEXT_PUBLIC_SUPABASE_URL is set" || echo "  - NEXT_PUBLIC_SUPABASE_URL is empty (optional)"
          [ -n "${NEXT_PUBLIC_SUPABASE_ANON_KEY}" ] && echo "  ✓ NEXT_PUBLIC_SUPABASE_ANON_KEY is set" || echo "  - NEXT_PUBLIC_SUPABASE_ANON_KEY is empty (optional)"
          [ -n "${NEXT_PUBLIC_GOOGLE_CLIENT_ID}" ] && echo "  ✓ NEXT_PUBLIC_GOOGLE_CLIENT_ID is set" || echo "  - NEXT_PUBLIC_GOOGLE_CLIENT_ID is empty (optional)"

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/aloshield-backend:latest
          cache-to: type=inline

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          build-args: |
            NEXT_PUBLIC_API_URL=${{ env.NEXT_PUBLIC_API_URL }}
            NEXT_PUBLIC_WS_URL=${{ env.NEXT_PUBLIC_WS_URL }}
            NEXT_PUBLIC_SUPABASE_URL=${{ env.NEXT_PUBLIC_SUPABASE_URL }}
            NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ env.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
            NEXT_PUBLIC_GOOGLE_CLIENT_ID=${{ env.NEXT_PUBLIC_GOOGLE_CLIENT_ID }}
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/aloshield-frontend:latest
          cache-to: type=inline

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Prepare environment files
        run: |
          echo "${{ secrets.ENV_BE }}" > /tmp/backend.env
          echo "${{ secrets.ENV_FE }}" > /tmp/frontend.env

      - name: Deploy to VPS
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} bash << 'ENDSSH'
            set -e
            
            APP_DIR="/opt/aloshield"
            sudo mkdir -p $APP_DIR
            sudo chown -R $USER:$USER $APP_DIR
            cd $APP_DIR
            
            # Pull or clone code
            if [ -d ".git" ]; then
              echo "Pulling latest code..."
              git fetch origin
              git reset --hard origin/main || git reset --hard origin/master
            else
              echo "Cloning repository..."
              git clone https://github.com/${{ github.repository }}.git .
            fi
          ENDSSH
          
          # Copy env files to server (ensure directories exist first)
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "mkdir -p /opt/aloshield/backend /opt/aloshield/frontend"
          scp -i ~/.ssh/deploy_key /tmp/backend.env ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/opt/aloshield/backend/.env
          scp -i ~/.ssh/deploy_key /tmp/frontend.env ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/opt/aloshield/frontend/.env
          
          # Pull images and start containers
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} bash << 'ENDSSH'
            set -e
            cd /opt/aloshield
            
            # Set Docker Hub username for docker-compose
            export DOCKER_USERNAME="${{ secrets.DOCKER_USERNAME }}"
            
            # Login to Docker Hub (if needed)
            echo "Logging in to Docker Hub..."
            echo "${{ secrets.DOCKER_ACCESS_TOKEN }}" | sudo docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin || true
            
            # Pull latest images
            echo "Pulling latest images from Docker Hub..."
            sudo docker pull ${{ secrets.DOCKER_USERNAME }}/aloshield-backend:latest || true
            sudo docker pull ${{ secrets.DOCKER_USERNAME }}/aloshield-frontend:latest || true
            
            # Stop and remove old containers
            echo "Stopping old containers..."
            sudo -E docker compose down || true
            
            # Check if Redis should be started (if REDIS_HOST=redis in backend/.env)
            if grep -q "^REDIS_HOST=redis" backend/.env; then
              echo "Starting Redis service with password from backend/.env..."
              
              # Verify REDIS_PASSWORD is set in .env
              if ! grep -q "^REDIS_PASSWORD=" backend/.env; then
                echo "⚠ WARNING: REDIS_PASSWORD not found in backend/.env"
              else
                REDIS_PASSWORD=$(grep "^REDIS_PASSWORD=" backend/.env | sed 's/^REDIS_PASSWORD=//' | tr -d '\r' | xargs)
                if [ -z "$REDIS_PASSWORD" ]; then
                  echo "⚠ WARNING: REDIS_PASSWORD is empty in backend/.env - Redis will start WITHOUT password"
                else
                  echo "✓ REDIS_PASSWORD found in backend/.env (length: ${#REDIS_PASSWORD} chars)"
                fi
              fi
              
              # Stop and remove existing Redis container to ensure fresh start with new password
              sudo docker stop aloshield-redis 2>/dev/null || true
              sudo docker rm aloshield-redis 2>/dev/null || true
              
              # Start Redis with new configuration
              sudo -E docker compose up -d redis
              echo "Waiting for Redis to be ready..."
              sleep 5
              
              # Verify Redis is running and password works
              if grep -q "^REDIS_PASSWORD=" backend/.env; then
                REDIS_PASSWORD=$(grep "^REDIS_PASSWORD=" backend/.env | sed 's/^REDIS_PASSWORD=//' | tr -d '\r' | xargs)
                if [ -n "$REDIS_PASSWORD" ]; then
                  echo "Verifying Redis password is working..."
                  if sudo docker exec aloshield-redis redis-cli -a "$REDIS_PASSWORD" ping 2>/dev/null | grep -q "PONG"; then
                    echo "✓ Redis password verified successfully"
                  else
                    echo "✗ ERROR: Redis password verification failed - check Redis logs"
                    sudo docker logs aloshield-redis --tail 20
                  fi
                fi
              fi
            else
              echo "Redis not configured (REDIS_HOST != redis) - skipping Redis service"
            fi
            
            # Start backend and frontend (will pull if not exists)
            echo "Starting containers..."
            sudo -E docker compose up -d backend frontend
            
            # Cleanup old images
            sudo docker image prune -f
            
            echo "Deploy completed!"
            sudo docker compose ps
          ENDSSH
          
          # Cleanup temp files
          rm -f /tmp/backend.env /tmp/frontend.env
